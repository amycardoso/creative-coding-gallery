---
import type { GetStaticPaths } from "astro";
import BaseLayout from "../layouts/BaseLayout.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import SketchCard from "../components/SketchCard.astro";
import { fetchSketches } from "../data/fetch-sketches";

export const getStaticPaths = (async ({ paginate }) => {
  const sketches = await fetchSketches();
  return paginate(sketches, { pageSize: 6 });
}) satisfies GetStaticPaths;

const { page } = Astro.props;
const nextUrl = page.url.next;

const allSketches = (await fetchSketches()).map((s) => ({
  slug: s.slug,
  title: s.title,
  description: s.description,
  tags: s.tags,
  tech: s.tech,
  mediaUrl: s.mediaUrl,
  width: s.width,
  height: s.height,
}));
const allTags = [...new Set(allSketches.flatMap((s) => s.tags))].sort();
const allTech = [...new Set(allSketches.flatMap((s) => s.tech))].sort();

const base = import.meta.env.BASE_URL;
---

<BaseLayout title="Creative Coding Gallery">
  <Header />
  <main class="container">
    <section class="gallery">
      <div class="filter-bar">
        <div class="filter-group" role="group" aria-label="Filter by tag">
          <span class="filter-label">Tags</span>
          {allTags.map((tag) => (
            <button
              class="filter-chip"
              data-filter-type="tags"
              data-filter-value={tag}
              aria-pressed="false"
            >
              {tag}
            </button>
          ))}
        </div>
        <div class="filter-group" role="group" aria-label="Filter by technology">
          <span class="filter-label">Tech</span>
          {allTech.map((t) => (
            <button
              class="filter-chip filter-chip--tech"
              data-filter-type="tech"
              data-filter-value={t}
              aria-pressed="false"
            >
              {t}
            </button>
          ))}
        </div>
        <div class="filter-actions" id="filter-actions">
          <button class="filter-clear" id="filter-clear">Clear filters</button>
          <span class="filter-status" id="filter-status" aria-live="polite"></span>
        </div>
      </div>

      <script type="application/json" id="sketches-data" set:html={JSON.stringify(allSketches)} />
      <script type="application/json" id="gallery-base" set:html={JSON.stringify(base)} />

      <div class="gallery-grid" id="gallery-grid">
        {page.data.map((sketch) => <SketchCard sketch={sketch} />)}
      </div>
      {nextUrl && <div id="scroll-sentinel" data-next={nextUrl}></div>}
      <p class="no-results" id="no-results">No sketches match the current filters.</p>
    </section>
  </main>
  <Footer />
</BaseLayout>

<style>
  .gallery {
    padding: var(--space-3xl) 0;
  }

  #scroll-sentinel {
    height: 1px;
  }
</style>

<script>
  const grid = document.getElementById("gallery-grid")!;
  const sentinel = document.getElementById("scroll-sentinel");
  const filterActions = document.getElementById("filter-actions")!;
  const filterClear = document.getElementById("filter-clear")!;
  const filterStatus = document.getElementById("filter-status")!;
  const noResults = document.getElementById("no-results")!;
  const chips = document.querySelectorAll<HTMLButtonElement>(".filter-chip");
  const sketches: Record<string, any>[] = JSON.parse(
    document.getElementById("sketches-data")!.textContent!,
  );
  const base: string = JSON.parse(
    document.getElementById("gallery-base")!.textContent!,
  );
  const totalCount = sketches.length;

  let mode: "paginated" | "filtered" = "paginated";
  let observer: IntersectionObserver | null = null;

  // ── Masonry ──────────────────────────────────────────────
  const COL_MIN_WIDTH = 340;
  let cols: HTMLDivElement[] = [];
  let colHeights: number[] = [];

  function getColCount() {
    const w = grid.clientWidth;
    if (w === 0) return 3;
    const gap = parseFloat(getComputedStyle(grid).gap) || 32;
    return Math.max(1, Math.floor((w + gap) / (COL_MIN_WIDTH + gap)));
  }

  function ensureColumns(count: number) {
    while (cols.length < count) {
      const col = document.createElement("div");
      col.className = "gallery-col";
      grid.appendChild(col);
      cols.push(col);
      colHeights.push(0);
    }
    while (cols.length > count) {
      const removed = cols.pop()!;
      const cards = [...removed.children];
      removed.remove();
      colHeights.pop();
      // redistribute orphaned cards
      for (const card of cards) appendToShortest(card as HTMLElement);
    }
  }

  function cardWeight(el: HTMLElement): number {
    const media = el.querySelector<HTMLElement>(".card-media");
    const ar = media?.style.aspectRatio;
    if (ar) {
      const [w, h] = ar.split("/").map(Number);
      if (w && h) return h / w;
    }
    return 1;
  }

  function appendToShortest(card: HTMLElement) {
    const idx = colHeights.indexOf(Math.min(...colHeights));
    cols[idx].appendChild(card);
    colHeights[idx] += cardWeight(card) + 0.4; // 0.4 ≈ card body
  }

  function buildMasonry(cards: HTMLElement[]) {
    const count = getColCount();
    cols = [];
    colHeights = [];
    grid.innerHTML = "";
    ensureColumns(count);
    for (const card of cards) appendToShortest(card);
  }

  // Initial setup: take server-rendered cards and distribute into columns
  const initialCards = [...grid.children] as HTMLElement[];
  buildMasonry(initialCards);

  // Rebuild on resize if column count changes
  let currentColCount = cols.length;
  const ro = new ResizeObserver(() => {
    const next = getColCount();
    if (next !== currentColCount) {
      currentColCount = next;
      const allCards = cols.flatMap((c) => [...c.children]) as HTMLElement[];
      buildMasonry(allCards);
    }
  });
  ro.observe(grid);

  // ── Helpers ──────────────────────────────────────────────
  function esc(str: string) {
    const el = document.createElement("span");
    el.textContent = str;
    return el.innerHTML;
  }

  function getFiltersFromUrl(): { tags: string[]; tech: string[] } {
    const params = new URLSearchParams(window.location.search);
    const tags = params.get("tags")?.split(",").filter(Boolean) ?? [];
    const tech = params.get("tech")?.split(",").filter(Boolean) ?? [];
    return { tags, tech };
  }

  function syncChipsToFilters(filters: Record<string, string[]>) {
    chips.forEach((chip) => {
      const type = chip.dataset.filterType!;
      const value = chip.dataset.filterValue!;
      const active = filters[type]?.includes(value) ?? false;
      chip.setAttribute("aria-pressed", String(active));
    });
  }

  function getFiltersFromChips() {
    const tags: string[] = [];
    const tech: string[] = [];
    chips.forEach((chip) => {
      if (chip.getAttribute("aria-pressed") === "true") {
        if (chip.dataset.filterType === "tags") tags.push(chip.dataset.filterValue!);
        else tech.push(chip.dataset.filterValue!);
      }
    });
    return { tags, tech };
  }

  function updateUrl(filters: Record<string, string[]>) {
    const params = new URLSearchParams();
    if (filters.tags.length) params.set("tags", filters.tags.join(","));
    if (filters.tech.length) params.set("tech", filters.tech.join(","));
    const qs = params.toString();
    const url = qs ? `${base}?${qs}` : base;
    history.replaceState(null, "", url);
  }

  function renderCard(s: (typeof sketches)[number]) {
    const tagSpans = s.tags
      .map((t: string) => `<span class="tag">${esc(t)}</span>`)
      .join("");
    const techSpans = s.tech
      .map((t: string) => `<span class="tag tag--tech">${esc(t)}</span>`)
      .join("");
    return `<a href="${base}${encodeURI(s.slug)}/" class="card-link">
      <article class="card">
        <div class="card-media" style="aspect-ratio:${s.width}/${s.height}">
          <img src="${esc(s.mediaUrl)}" alt="${esc(s.title)}" width="${s.width}" height="${s.height}" loading="lazy" decoding="async" onload="this.classList.add('loaded')" />
        </div>
        <div class="card-body">
          <h2 class="card-title">${esc(s.title)}</h2>
          <p class="card-description">${esc(s.description)}</p>
          <div class="tags">${tagSpans}${techSpans}</div>
        </div>
      </article>
    </a>`;
  }

  function htmlToElements(html: string): HTMLElement[] {
    const tmp = document.createElement("div");
    tmp.innerHTML = html;
    return [...tmp.children] as HTMLElement[];
  }

  // ── Filters ──────────────────────────────────────────────
  function applyFilters() {
    const filters = getFiltersFromChips();
    const hasFilters = filters.tags.length > 0 || filters.tech.length > 0;

    if (!hasFilters) {
      window.location.href = base;
      return;
    }

    mode = "filtered";

    if (sentinel) sentinel.style.display = "none";
    if (observer) observer.disconnect();

    const matched = sketches.filter((s) => {
      const matchTags =
        filters.tags.length === 0 ||
        filters.tags.some((t: string) => s.tags.includes(t));
      const matchTech =
        filters.tech.length === 0 ||
        filters.tech.some((t: string) => s.tech.includes(t));
      return matchTags && matchTech;
    });

    grid.classList.add("gallery-grid--filtered");
    const cards = htmlToElements(matched.map(renderCard).join(""));
    buildMasonry(cards);

    filterActions.classList.add("active");
    filterStatus.textContent = `Showing ${matched.length} of ${totalCount} sketches`;
    noResults.style.display = matched.length === 0 ? "block" : "none";

    updateUrl(filters);
  }

  function clearFilters() {
    window.location.href = base;
  }

  // ── Infinite scroll ──────────────────────────────────────
  function initInfiniteScroll() {
    if (!sentinel) return;

    let nextUrl = sentinel.dataset.next;
    let loading = false;

    observer = new IntersectionObserver(
      async (entries) => {
        if (!entries[0].isIntersecting || loading || !nextUrl || mode !== "paginated") return;
        loading = true;

        const res = await fetch(nextUrl);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, "text/html");

        const newCards = doc.querySelectorAll("#gallery-grid > *");
        for (const card of newCards) {
          appendToShortest(document.adoptNode(card) as HTMLElement);
        }

        const newSentinel = doc.getElementById("scroll-sentinel");
        if (newSentinel?.dataset.next) {
          nextUrl = newSentinel.dataset.next;
        } else {
          observer!.disconnect();
          sentinel.remove();
        }

        loading = false;
      },
      { rootMargin: "200px" },
    );

    observer.observe(sentinel);
  }

  // ── Events ───────────────────────────────────────────────
  chips.forEach((chip) => {
    chip.addEventListener("click", () => {
      const pressed = chip.getAttribute("aria-pressed") === "true";
      chip.setAttribute("aria-pressed", String(!pressed));
      applyFilters();
    });
  });

  filterClear.addEventListener("click", clearFilters);

  window.addEventListener("popstate", () => {
    const filters = getFiltersFromUrl();
    const hasFilters = filters.tags.length > 0 || filters.tech.length > 0;
    if (hasFilters) {
      syncChipsToFilters(filters);
      applyFilters();
    } else {
      window.location.href = base;
    }
  });

  const initialFilters = getFiltersFromUrl();
  const hasInitialFilters =
    initialFilters.tags.length > 0 || initialFilters.tech.length > 0;

  if (hasInitialFilters) {
    syncChipsToFilters(initialFilters);
    applyFilters();
  } else {
    initInfiniteScroll();
  }
</script>
